{"ast":null,"code":"import _defineProperty from 'babel-runtime/helpers/defineProperty';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';\nimport classNames from 'classnames';\nimport PropTypes from '../../_util/vue-types';\nimport BaseMixin from '../../_util/BaseMixin';\nimport { initDefaultProps, hasProp } from '../../_util/props-util';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar _trimAlignValue = function _trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar rangeProps = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: PropTypes.number,\n  pushable: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\n  allowCross: PropTypes.bool,\n  disabled: PropTypes.bool,\n  reverse: PropTypes.bool,\n  tabIndex: PropTypes.arrayOf(PropTypes.number),\n  prefixCls: PropTypes.string,\n  min: PropTypes.number,\n  max: PropTypes.number,\n  autoFocus: PropTypes.bool\n};\nvar Range = {\n  name: 'Range',\n  displayName: 'Range',\n  mixins: [BaseMixin],\n  props: initDefaultProps(rangeProps, {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabIndex: []\n  }),\n  data: function data() {\n    var _this = this;\n\n    var count = this.count,\n        min = this.min,\n        max = this.max;\n    var initialValue = Array.apply(undefined, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = hasProp(this, 'defaultValue') ? this.defaultValue : initialValue;\n    var value = this.value;\n\n    if (value === undefined) {\n      value = defaultValue;\n    }\n\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: _this.$props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    return {\n      sHandle: null,\n      recent: recent,\n      bounds: bounds\n    };\n  },\n  watch: {\n    value: {\n      handler: function handler(val) {\n        var bounds = this.bounds;\n        this.setChangeValue(val || bounds);\n      },\n      deep: true\n    },\n    min: function min() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    },\n    max: function max() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    }\n  },\n  methods: {\n    setChangeValue: function setChangeValue(value) {\n      var _this2 = this;\n\n      var bounds = this.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: bounds,\n          props: _this2.$props\n        });\n      });\n      if (nextBounds.length === bounds.length && nextBounds.every(function (v, i) {\n        return v === bounds[i];\n      })) return;\n      this.setState({\n        bounds: nextBounds\n      });\n\n      if (value.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.$props);\n      })) {\n        var newValues = value.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.$props);\n        });\n        this.$emit('change', newValues);\n      }\n    },\n    onChange: function onChange(state) {\n      var isNotControlled = !hasProp(this, 'value');\n\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['sHandle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _extends({}, this.$data, state);\n\n      var changedValue = data.bounds;\n      this.$emit('change', changedValue);\n    },\n    onStart: function onStart(position) {\n      var bounds = this.bounds;\n      this.$emit('beforeChange', bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        sHandle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n      var nextBounds = [].concat(_toConsumableArray(bounds));\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    },\n    onEnd: function onEnd(force) {\n      var sHandle = this.sHandle;\n      this.removeDocumentEvents();\n\n      if (sHandle !== null || force) {\n        this.$emit('afterChange', this.bounds);\n      }\n\n      this.setState({\n        sHandle: null\n      });\n    },\n    onMove: function onMove(e, position) {\n      utils.pauseEvent(e);\n      var bounds = this.bounds,\n          sHandle = this.sHandle;\n      var value = this.calcValueByPos(position);\n      var oldValue = bounds[sHandle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    },\n    onKeyboard: function onKeyboard(e) {\n      var _$props = this.$props,\n          reverse = _$props.reverse,\n          vertical = _$props.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var bounds = this.bounds,\n            sHandle = this.sHandle;\n        var oldValue = bounds[sHandle === null ? this.recent : sHandle];\n        var mutatedValue = valueMutator(oldValue, this.$props);\n\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: sHandle,\n          bounds: bounds,\n          props: this.$props\n        });\n\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    },\n    getClosestBound: function getClosestBound(value) {\n      var bounds = this.bounds;\n      var closestBound = 0;\n\n      for (var i = 1; i < bounds.length - 1; ++i) {\n        if (value > bounds[i]) {\n          closestBound = i;\n        }\n      }\n\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n\n      return closestBound;\n    },\n    getBoundNeedMoving: function getBoundNeedMoving(value, closestBound) {\n      var bounds = this.bounds,\n          recent = this.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n\n      return boundNeedMoving;\n    },\n    getLowerBound: function getLowerBound() {\n      return this.bounds[0];\n    },\n    getUpperBound: function getUpperBound() {\n      var bounds = this.bounds;\n      return bounds[bounds.length - 1];\n    },\n\n    /**\r\n     * Returns an array of possible slider points, taking into account both\r\n     * `marks` and `step`. The result is cached.\r\n     */\n    getPoints: function getPoints() {\n      var marks = this.marks,\n          step = this.step,\n          min = this.min,\n          max = this.max;\n      var cache = this._getPointsCache;\n\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _extends({}, marks);\n\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this._getPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n\n      return this._getPointsCache.points;\n    },\n    moveTo: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var nextBounds = [].concat(_toConsumableArray(this.bounds));\n      var sHandle = this.sHandle,\n          recent = this.recent;\n      var handle = sHandle === null ? recent : sHandle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n\n      if (this.$props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (this.$props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n\n      this.onChange({\n        recent: nextHandle,\n        sHandle: nextHandle,\n        bounds: nextBounds\n      });\n\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.$emit('afterChange', nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    },\n    pushSurroundingHandles: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var threshold = this.pushable;\n      threshold = Number(threshold);\n      var direction = 0;\n\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    },\n    pushHandle: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n\n      return true;\n    },\n    pushHandleOnePoint: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var threshold = this.pushable;\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n\n\n      bounds[handle] = nextValue;\n      return true;\n    },\n    trimAlignValue: function trimAlignValue(value) {\n      var sHandle = this.sHandle,\n          bounds = this.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: sHandle,\n        bounds: bounds,\n        props: this.$props\n      });\n    },\n    ensureValueNotConflict: function ensureValueNotConflict(handle, val, _ref2) {\n      var allowCross = _ref2.allowCross,\n          thershold = _ref2.pushable;\n      var state = this.$data || {};\n      var bounds = state.bounds;\n      handle = handle === undefined ? state.sHandle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n\n\n      return val;\n    },\n    getTrack: function getTrack(_ref3) {\n      var bounds = _ref3.bounds,\n          prefixCls = _ref3.prefixCls,\n          reverse = _ref3.reverse,\n          vertical = _ref3.vertical,\n          included = _ref3.included,\n          offsets = _ref3.offsets,\n          trackStyle = _ref3.trackStyle;\n      var h = this.$createElement;\n      return bounds.slice(0, -1).map(function (_, index) {\n        var _classNames;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames = {}, _defineProperty(_classNames, prefixCls + '-track', true), _defineProperty(_classNames, prefixCls + '-track-' + i, true), _classNames));\n        return h(Track, {\n          'class': trackClassName,\n          attrs: {\n            vertical: vertical,\n            reverse: reverse,\n            included: included,\n            offset: offsets[i - 1],\n            length: offsets[i] - offsets[i - 1]\n          },\n          style: trackStyle[index],\n          key: i\n        });\n      });\n    },\n    renderSlider: function renderSlider() {\n      var _this4 = this;\n\n      var sHandle = this.sHandle,\n          bounds = this.bounds,\n          prefixCls = this.prefixCls,\n          vertical = this.vertical,\n          included = this.included,\n          disabled = this.disabled,\n          min = this.min,\n          max = this.max,\n          reverse = this.reverse,\n          handle = this.handle,\n          defaultHandle = this.defaultHandle,\n          trackStyle = this.trackStyle,\n          handleStyle = this.handleStyle,\n          tabIndex = this.tabIndex;\n      var handleGenerator = handle || defaultHandle;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = prefixCls + '-handle';\n      var handles = bounds.map(function (v, i) {\n        var _classNames2;\n\n        var _tabIndex = tabIndex[i] || 0;\n\n        if (disabled || tabIndex[i] === null) {\n          _tabIndex = null;\n        }\n\n        return handleGenerator({\n          className: classNames((_classNames2 = {}, _defineProperty(_classNames2, handleClassName, true), _defineProperty(_classNames2, handleClassName + '-' + (i + 1), true), _classNames2)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          offset: offsets[i],\n          value: v,\n          dragging: sHandle === i,\n          index: i,\n          tabIndex: _tabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          directives: [{\n            name: 'ant-ref',\n            value: function value(h) {\n              return _this4.saveHandle(i, h);\n            }\n          }],\n          on: {\n            focus: _this4.onFocus,\n            blur: _this4.onBlur\n          }\n        });\n      });\n      return {\n        tracks: this.getTrack({\n          bounds: bounds,\n          prefixCls: prefixCls,\n          reverse: reverse,\n          vertical: vertical,\n          included: included,\n          offsets: offsets,\n          trackStyle: trackStyle\n        }),\n        handles: handles\n      };\n    }\n  }\n};\nexport default createSlider(Range);","map":{"version":3,"names":["_defineProperty","_extends","_toConsumableArray","classNames","PropTypes","BaseMixin","initDefaultProps","hasProp","Track","createSlider","utils","_trimAlignValue","_ref","value","handle","bounds","props","allowCross","pushable","thershold","Number","valInRange","ensureValueInRange","valNotConflict","undefined","length","ensureValuePrecision","rangeProps","defaultValue","arrayOf","number","count","oneOfType","bool","disabled","reverse","tabIndex","prefixCls","string","min","max","autoFocus","Range","name","displayName","mixins","data","_this","initialValue","Array","apply","map","v","i","$props","recent","sHandle","watch","handler","val","setChangeValue","deep","methods","_this2","nextBounds","every","setState","some","isValueOutOfRange","newValues","$emit","onChange","state","isNotControlled","controlledState","forEach","item","Object","keys","$data","changedValue","onStart","position","calcValueByPos","startValue","startPosition","closestBound","getClosestBound","prevMovedHandleIndex","getBoundNeedMoving","prevValue","concat","onEnd","force","removeDocumentEvents","onMove","e","pauseEvent","oldValue","moveTo","onKeyboard","_$props","vertical","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","Math","abs","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","marks","step","cache","_getPointsCache","pointsObject","point","points","parseFloat","sort","a","b","_this3","nextHandle","pushSurroundingHandles","indexOf","handlesRefs","focus","threshold","direction","diffToNext","pushHandle","amount","originalValue","currentValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","trimAlignValue","ensureValueNotConflict","_ref2","getTrack","_ref3","included","offsets","trackStyle","h","$createElement","slice","_","index","_classNames","trackClassName","attrs","offset","style","key","renderSlider","_this4","defaultHandle","handleStyle","handleGenerator","calcOffset","handleClassName","handles","_classNames2","_tabIndex","className","dragging","directives","saveHandle","on","onFocus","blur","onBlur","tracks"],"sources":["D:/Desktop/大三上/实训/项目2.0/xbr/xbr/前端/node_modules/ant-design-vue/es/vc-slider/src/Range.js"],"sourcesContent":["import _defineProperty from 'babel-runtime/helpers/defineProperty';\r\nimport _extends from 'babel-runtime/helpers/extends';\r\nimport _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';\r\nimport classNames from 'classnames';\r\nimport PropTypes from '../../_util/vue-types';\r\nimport BaseMixin from '../../_util/BaseMixin';\r\nimport { initDefaultProps, hasProp } from '../../_util/props-util';\r\nimport Track from './common/Track';\r\nimport createSlider from './common/createSlider';\r\nimport * as utils from './utils';\r\n\r\nvar _trimAlignValue = function _trimAlignValue(_ref) {\r\n  var value = _ref.value,\r\n      handle = _ref.handle,\r\n      bounds = _ref.bounds,\r\n      props = _ref.props;\r\n  var allowCross = props.allowCross,\r\n      pushable = props.pushable;\r\n\r\n  var thershold = Number(pushable);\r\n  var valInRange = utils.ensureValueInRange(value, props);\r\n  var valNotConflict = valInRange;\r\n  if (!allowCross && handle != null && bounds !== undefined) {\r\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\r\n      valNotConflict = bounds[handle - 1] + thershold;\r\n    }\r\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\r\n      valNotConflict = bounds[handle + 1] - thershold;\r\n    }\r\n  }\r\n  return utils.ensureValuePrecision(valNotConflict, props);\r\n};\r\n\r\nvar rangeProps = {\r\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\r\n  value: PropTypes.arrayOf(PropTypes.number),\r\n  count: PropTypes.number,\r\n  pushable: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\r\n  allowCross: PropTypes.bool,\r\n  disabled: PropTypes.bool,\r\n  reverse: PropTypes.bool,\r\n  tabIndex: PropTypes.arrayOf(PropTypes.number),\r\n  prefixCls: PropTypes.string,\r\n  min: PropTypes.number,\r\n  max: PropTypes.number,\r\n  autoFocus: PropTypes.bool\r\n};\r\nvar Range = {\r\n  name: 'Range',\r\n  displayName: 'Range',\r\n  mixins: [BaseMixin],\r\n  props: initDefaultProps(rangeProps, {\r\n    count: 1,\r\n    allowCross: true,\r\n    pushable: false,\r\n    tabIndex: []\r\n  }),\r\n  data: function data() {\r\n    var _this = this;\r\n\r\n    var count = this.count,\r\n        min = this.min,\r\n        max = this.max;\r\n\r\n    var initialValue = Array.apply(undefined, _toConsumableArray(Array(count + 1))).map(function () {\r\n      return min;\r\n    });\r\n    var defaultValue = hasProp(this, 'defaultValue') ? this.defaultValue : initialValue;\r\n    var value = this.value;\r\n\r\n    if (value === undefined) {\r\n      value = defaultValue;\r\n    }\r\n    var bounds = value.map(function (v, i) {\r\n      return _trimAlignValue({\r\n        value: v,\r\n        handle: i,\r\n        props: _this.$props\r\n      });\r\n    });\r\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\r\n    return {\r\n      sHandle: null,\r\n      recent: recent,\r\n      bounds: bounds\r\n    };\r\n  },\r\n\r\n  watch: {\r\n    value: {\r\n      handler: function handler(val) {\r\n        var bounds = this.bounds;\r\n\r\n        this.setChangeValue(val || bounds);\r\n      },\r\n\r\n      deep: true\r\n    },\r\n    min: function min() {\r\n      var value = this.value;\r\n\r\n      this.setChangeValue(value || this.bounds);\r\n    },\r\n    max: function max() {\r\n      var value = this.value;\r\n\r\n      this.setChangeValue(value || this.bounds);\r\n    }\r\n  },\r\n  methods: {\r\n    setChangeValue: function setChangeValue(value) {\r\n      var _this2 = this;\r\n\r\n      var bounds = this.bounds;\r\n\r\n      var nextBounds = value.map(function (v, i) {\r\n        return _trimAlignValue({\r\n          value: v,\r\n          handle: i,\r\n          bounds: bounds,\r\n          props: _this2.$props\r\n        });\r\n      });\r\n      if (nextBounds.length === bounds.length && nextBounds.every(function (v, i) {\r\n        return v === bounds[i];\r\n      })) return;\r\n\r\n      this.setState({ bounds: nextBounds });\r\n\r\n      if (value.some(function (v) {\r\n        return utils.isValueOutOfRange(v, _this2.$props);\r\n      })) {\r\n        var newValues = value.map(function (v) {\r\n          return utils.ensureValueInRange(v, _this2.$props);\r\n        });\r\n        this.$emit('change', newValues);\r\n      }\r\n    },\r\n    onChange: function onChange(state) {\r\n      var isNotControlled = !hasProp(this, 'value');\r\n      if (isNotControlled) {\r\n        this.setState(state);\r\n      } else {\r\n        var controlledState = {};\r\n\r\n        ['sHandle', 'recent'].forEach(function (item) {\r\n          if (state[item] !== undefined) {\r\n            controlledState[item] = state[item];\r\n          }\r\n        });\r\n\r\n        if (Object.keys(controlledState).length) {\r\n          this.setState(controlledState);\r\n        }\r\n      }\r\n\r\n      var data = _extends({}, this.$data, state);\r\n      var changedValue = data.bounds;\r\n      this.$emit('change', changedValue);\r\n    },\r\n    onStart: function onStart(position) {\r\n      var bounds = this.bounds;\r\n\r\n      this.$emit('beforeChange', bounds);\r\n\r\n      var value = this.calcValueByPos(position);\r\n      this.startValue = value;\r\n      this.startPosition = position;\r\n\r\n      var closestBound = this.getClosestBound(value);\r\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\r\n\r\n      this.setState({\r\n        sHandle: this.prevMovedHandleIndex,\r\n        recent: this.prevMovedHandleIndex\r\n      });\r\n\r\n      var prevValue = bounds[this.prevMovedHandleIndex];\r\n      if (value === prevValue) return;\r\n      var nextBounds = [].concat(_toConsumableArray(bounds));\r\n      nextBounds[this.prevMovedHandleIndex] = value;\r\n      this.onChange({ bounds: nextBounds });\r\n    },\r\n    onEnd: function onEnd(force) {\r\n      var sHandle = this.sHandle;\r\n\r\n      this.removeDocumentEvents();\r\n      if (sHandle !== null || force) {\r\n        this.$emit('afterChange', this.bounds);\r\n      }\r\n      this.setState({ sHandle: null });\r\n    },\r\n    onMove: function onMove(e, position) {\r\n      utils.pauseEvent(e);\r\n      var bounds = this.bounds,\r\n          sHandle = this.sHandle;\r\n\r\n      var value = this.calcValueByPos(position);\r\n      var oldValue = bounds[sHandle];\r\n      if (value === oldValue) return;\r\n\r\n      this.moveTo(value);\r\n    },\r\n    onKeyboard: function onKeyboard(e) {\r\n      var _$props = this.$props,\r\n          reverse = _$props.reverse,\r\n          vertical = _$props.vertical;\r\n\r\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\r\n\r\n      if (valueMutator) {\r\n        utils.pauseEvent(e);\r\n        var bounds = this.bounds,\r\n            sHandle = this.sHandle;\r\n\r\n        var oldValue = bounds[sHandle === null ? this.recent : sHandle];\r\n        var mutatedValue = valueMutator(oldValue, this.$props);\r\n        var value = _trimAlignValue({\r\n          value: mutatedValue,\r\n          handle: sHandle,\r\n          bounds: bounds,\r\n          props: this.$props\r\n        });\r\n        if (value === oldValue) return;\r\n        var isFromKeyboardEvent = true;\r\n        this.moveTo(value, isFromKeyboardEvent);\r\n      }\r\n    },\r\n    getClosestBound: function getClosestBound(value) {\r\n      var bounds = this.bounds;\r\n\r\n      var closestBound = 0;\r\n      for (var i = 1; i < bounds.length - 1; ++i) {\r\n        if (value > bounds[i]) {\r\n          closestBound = i;\r\n        }\r\n      }\r\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\r\n        closestBound += 1;\r\n      }\r\n      return closestBound;\r\n    },\r\n    getBoundNeedMoving: function getBoundNeedMoving(value, closestBound) {\r\n      var bounds = this.bounds,\r\n          recent = this.recent;\r\n\r\n      var boundNeedMoving = closestBound;\r\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\r\n\r\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\r\n        boundNeedMoving = recent;\r\n      }\r\n\r\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\r\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\r\n      }\r\n      return boundNeedMoving;\r\n    },\r\n    getLowerBound: function getLowerBound() {\r\n      return this.bounds[0];\r\n    },\r\n    getUpperBound: function getUpperBound() {\r\n      var bounds = this.bounds;\r\n\r\n      return bounds[bounds.length - 1];\r\n    },\r\n\r\n    /**\r\n     * Returns an array of possible slider points, taking into account both\r\n     * `marks` and `step`. The result is cached.\r\n     */\r\n    getPoints: function getPoints() {\r\n      var marks = this.marks,\r\n          step = this.step,\r\n          min = this.min,\r\n          max = this.max;\r\n\r\n      var cache = this._getPointsCache;\r\n      if (!cache || cache.marks !== marks || cache.step !== step) {\r\n        var pointsObject = _extends({}, marks);\r\n        if (step !== null) {\r\n          for (var point = min; point <= max; point += step) {\r\n            pointsObject[point] = point;\r\n          }\r\n        }\r\n        var points = Object.keys(pointsObject).map(parseFloat);\r\n        points.sort(function (a, b) {\r\n          return a - b;\r\n        });\r\n        this._getPointsCache = { marks: marks, step: step, points: points };\r\n      }\r\n      return this._getPointsCache.points;\r\n    },\r\n    moveTo: function moveTo(value, isFromKeyboardEvent) {\r\n      var _this3 = this;\r\n\r\n      var nextBounds = [].concat(_toConsumableArray(this.bounds));\r\n      var sHandle = this.sHandle,\r\n          recent = this.recent;\r\n\r\n      var handle = sHandle === null ? recent : sHandle;\r\n      nextBounds[handle] = value;\r\n      var nextHandle = handle;\r\n      if (this.$props.pushable !== false) {\r\n        this.pushSurroundingHandles(nextBounds, nextHandle);\r\n      } else if (this.$props.allowCross) {\r\n        nextBounds.sort(function (a, b) {\r\n          return a - b;\r\n        });\r\n        nextHandle = nextBounds.indexOf(value);\r\n      }\r\n      this.onChange({\r\n        recent: nextHandle,\r\n        sHandle: nextHandle,\r\n        bounds: nextBounds\r\n      });\r\n      if (isFromKeyboardEvent) {\r\n        // known problem: because setState is async,\r\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\r\n        // cause onBeforeChange and onAfterChange receive wrong value.\r\n        // here use setState callback to hack，but not elegant\r\n        this.$emit('afterChange', nextBounds);\r\n        this.setState({}, function () {\r\n          _this3.handlesRefs[nextHandle].focus();\r\n        });\r\n        this.onEnd();\r\n      }\r\n    },\r\n    pushSurroundingHandles: function pushSurroundingHandles(bounds, handle) {\r\n      var value = bounds[handle];\r\n      var threshold = this.pushable;\r\n\r\n      threshold = Number(threshold);\r\n\r\n      var direction = 0;\r\n      if (bounds[handle + 1] - value < threshold) {\r\n        direction = +1; // push to right\r\n      }\r\n      if (value - bounds[handle - 1] < threshold) {\r\n        direction = -1; // push to left\r\n      }\r\n\r\n      if (direction === 0) {\r\n        return;\r\n      }\r\n\r\n      var nextHandle = handle + direction;\r\n      var diffToNext = direction * (bounds[nextHandle] - value);\r\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\r\n        // revert to original value if pushing is impossible\r\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\r\n      }\r\n    },\r\n    pushHandle: function pushHandle(bounds, handle, direction, amount) {\r\n      var originalValue = bounds[handle];\r\n      var currentValue = bounds[handle];\r\n      while (direction * (currentValue - originalValue) < amount) {\r\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\r\n          // can't push handle enough to create the needed `amount` gap, so we\r\n          // revert its position to the original value\r\n          bounds[handle] = originalValue;\r\n          return false;\r\n        }\r\n        currentValue = bounds[handle];\r\n      }\r\n      // the handle was pushed enough to create the needed `amount` gap\r\n      return true;\r\n    },\r\n    pushHandleOnePoint: function pushHandleOnePoint(bounds, handle, direction) {\r\n      var points = this.getPoints();\r\n      var pointIndex = points.indexOf(bounds[handle]);\r\n      var nextPointIndex = pointIndex + direction;\r\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\r\n        // reached the minimum or maximum available point, can't push anymore\r\n        return false;\r\n      }\r\n      var nextHandle = handle + direction;\r\n      var nextValue = points[nextPointIndex];\r\n      var threshold = this.pushable;\r\n\r\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\r\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\r\n        // couldn't push next handle, so we won't push this one either\r\n        return false;\r\n      }\r\n      // push the handle\r\n      bounds[handle] = nextValue;\r\n      return true;\r\n    },\r\n    trimAlignValue: function trimAlignValue(value) {\r\n      var sHandle = this.sHandle,\r\n          bounds = this.bounds;\r\n\r\n      return _trimAlignValue({\r\n        value: value,\r\n        handle: sHandle,\r\n        bounds: bounds,\r\n        props: this.$props\r\n      });\r\n    },\r\n    ensureValueNotConflict: function ensureValueNotConflict(handle, val, _ref2) {\r\n      var allowCross = _ref2.allowCross,\r\n          thershold = _ref2.pushable;\r\n\r\n      var state = this.$data || {};\r\n      var bounds = state.bounds;\r\n\r\n      handle = handle === undefined ? state.sHandle : handle;\r\n      thershold = Number(thershold);\r\n      /* eslint-disable eqeqeq */\r\n      if (!allowCross && handle != null && bounds !== undefined) {\r\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\r\n          return bounds[handle - 1] + thershold;\r\n        }\r\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\r\n          return bounds[handle + 1] - thershold;\r\n        }\r\n      }\r\n      /* eslint-enable eqeqeq */\r\n      return val;\r\n    },\r\n    getTrack: function getTrack(_ref3) {\r\n      var bounds = _ref3.bounds,\r\n          prefixCls = _ref3.prefixCls,\r\n          reverse = _ref3.reverse,\r\n          vertical = _ref3.vertical,\r\n          included = _ref3.included,\r\n          offsets = _ref3.offsets,\r\n          trackStyle = _ref3.trackStyle;\r\n      var h = this.$createElement;\r\n\r\n      return bounds.slice(0, -1).map(function (_, index) {\r\n        var _classNames;\r\n\r\n        var i = index + 1;\r\n        var trackClassName = classNames((_classNames = {}, _defineProperty(_classNames, prefixCls + '-track', true), _defineProperty(_classNames, prefixCls + '-track-' + i, true), _classNames));\r\n        return h(Track, {\r\n          'class': trackClassName,\r\n          attrs: { vertical: vertical,\r\n            reverse: reverse,\r\n            included: included,\r\n            offset: offsets[i - 1],\r\n            length: offsets[i] - offsets[i - 1]\r\n          },\r\n          style: trackStyle[index],\r\n          key: i\r\n        });\r\n      });\r\n    },\r\n    renderSlider: function renderSlider() {\r\n      var _this4 = this;\r\n\r\n      var sHandle = this.sHandle,\r\n          bounds = this.bounds,\r\n          prefixCls = this.prefixCls,\r\n          vertical = this.vertical,\r\n          included = this.included,\r\n          disabled = this.disabled,\r\n          min = this.min,\r\n          max = this.max,\r\n          reverse = this.reverse,\r\n          handle = this.handle,\r\n          defaultHandle = this.defaultHandle,\r\n          trackStyle = this.trackStyle,\r\n          handleStyle = this.handleStyle,\r\n          tabIndex = this.tabIndex;\r\n\r\n      var handleGenerator = handle || defaultHandle;\r\n      var offsets = bounds.map(function (v) {\r\n        return _this4.calcOffset(v);\r\n      });\r\n\r\n      var handleClassName = prefixCls + '-handle';\r\n      var handles = bounds.map(function (v, i) {\r\n        var _classNames2;\r\n\r\n        var _tabIndex = tabIndex[i] || 0;\r\n        if (disabled || tabIndex[i] === null) {\r\n          _tabIndex = null;\r\n        }\r\n        return handleGenerator({\r\n          className: classNames((_classNames2 = {}, _defineProperty(_classNames2, handleClassName, true), _defineProperty(_classNames2, handleClassName + '-' + (i + 1), true), _classNames2)),\r\n          prefixCls: prefixCls,\r\n          vertical: vertical,\r\n          offset: offsets[i],\r\n          value: v,\r\n          dragging: sHandle === i,\r\n          index: i,\r\n          tabIndex: _tabIndex,\r\n          min: min,\r\n          max: max,\r\n          reverse: reverse,\r\n          disabled: disabled,\r\n          style: handleStyle[i],\r\n          directives: [{\r\n            name: 'ant-ref',\r\n            value: function value(h) {\r\n              return _this4.saveHandle(i, h);\r\n            }\r\n          }],\r\n          on: {\r\n            focus: _this4.onFocus,\r\n            blur: _this4.onBlur\r\n          }\r\n        });\r\n      });\r\n\r\n      return {\r\n        tracks: this.getTrack({\r\n          bounds: bounds,\r\n          prefixCls: prefixCls,\r\n          reverse: reverse,\r\n          vertical: vertical,\r\n          included: included,\r\n          offsets: offsets,\r\n          trackStyle: trackStyle\r\n        }),\r\n        handles: handles\r\n      };\r\n    }\r\n  }\r\n};\r\n\r\nexport default createSlider(Range);"],"mappings":"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"},"metadata":{},"sourceType":"module"}